[{"title":"Updating a player's data through cache","type":0,"sectionRef":"#","url":"/DocumentService/docs/cache","content":"Updating a player's data through cache Most of the time, you'll want to update player data like this: local data = table.clone(document:GetCache()) data.Points += points document:SetCache(newData) For Robux transactions remember to call Save to ensure they save!","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"/DocumentService/docs/intro","content":"Introduction DocumentService is a fully strictly typed Luau library for saving data with Roblox DataStores. DocumentService provides a DataStore abstraction, DocumentStore, which holds data about entities within Documents. A document can represent data about anything - e.g. a player, a group, or a virtual house shared between players. DocumentStores can be session-locked or not session-locked. DocumentStores which aren't session locked are designed to be used for shared data which needs multiple-server editing. This will disable some methods, such as caching - you should write directly to the DataStore every time you make an update. You should use session locking where you can to take full advantage of the library. See README.md for more information.","keywords":""},{"title":"Waiting for a Document to open","type":0,"sectionRef":"#","url":"/DocumentService/docs/waiting","content":"Waiting for a Document to open Use document:GetOpenedSignal():Wait().","keywords":""},{"title":"Developer Products","type":0,"sectionRef":"#","url":"/DocumentService/docs/products","content":"Developer Products There is no example here yet. Feel free to make one, oradapt the example from Lapis instead.","keywords":""},{"title":"Opening a player document","type":0,"sectionRef":"#","url":"/DocumentService/docs/opening","content":"Opening a player document This is an example of how to open a document for a DocumentStore that deals with player data. Opening a session-locked document will enable autosaves. At the time of writing, these happen every 150 seconds. The following code should run on Players.PlayerAdded: local document = store:GetDocument(tostring(player.UserId)) local result = document:Open() -- DocumentService retries 5 times over 16 seconds, so it is safe to steal -- after a failed `:Open`! if not result.success and result.reason == &quot;SessionLockedError&quot; then document:Steal() result = document:Open() end if not result.success then if result.reason == &quot;BackwardsCompatibilityError&quot; then player:Kick( &quot;You joined an old server which does not support your saved data.&quot; .. &quot;Please try joining another server. If this persists, contact a developer.&quot; ) end if result.reason == &quot;RobloxAPIError&quot; then player:Kick(&quot;Failed to load data due to a Roblox service issue. Try again later.&quot;) end player:Kick( `Failed to load data: {result.reason}. Please screenshot this message and report it to a developer.` ) return false end You should close documents when a player leaves. Note that I have not created a player documents table. You should use :GetDocument to retrieve the document - there is usually no need to create a table to reference your player documents. See the API reference for GetDocument for information on when documents are garbage collected.","keywords":""},{"title":"Migrations","type":0,"sectionRef":"#","url":"/DocumentService/docs/migrations","content":"Migrations There is no example here yet. However, migrations in DocumentService are very similar to migrations in Lapis, which has a good tutorial page here. Have a good example with a well-written explanation? Contribute here!","keywords":""},{"title":"Creating a DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/docs/creating","content":"Creating a DocumentStore You need a DocumentStore to get documents to work with! Here's an example of creating one: type DataSchema = { points: number, } local DataInterface = { coins = Guard.Integer, } local function dataCheck(value: unknown): DataSchema assert(type(value) == &quot;table&quot;, &quot;Data must be a table&quot;) local Value: any = value return { coins = DataInterface.coins(Value.coins), } end local store = DocumentStore.new({ dataStore = DataStoreService:GetDataStore(&quot;Test&quot;) :: any, -- For mockDataStores use below! --dataStore = MockDataStore:GetDataStore(&quot;Mock&quot;), check = Guard.Check(dataCheck), default = { coins = 100, }, migrations = {}, lockSessions = true, }) This example uses Guard. You need to cast DataStore to any currently - while this library does dependency inversion properly - Roblox's Luau types don't work well with it! Remember it is important not to create duplicate DocumentStores - they will be treated like separate sessions! If you need to access a DocumentStore from multiple scripts, make sure to create and return it from a module.","keywords":""},{"title":"Error Handling","type":0,"sectionRef":"#","url":"/DocumentService/docs/errors","content":"Error Handling In DocumentService, anything that is definitely a problem with your code will throw an explicit Luau error. Examples of this include your migrations erroring, or trying to update data in a way that would break the schema. These also won't fire any signals or hooks. You shouldn't need to explicitly catch these. Other things, where there is a possibility the problem is external (e.g. data modified, Roblox API failure, session locks) return errors through the Result type. These should be explicitly caught. Currently trying to open a document when the game is closing results in an explicit error, and you are expected to check the game is not closing first.","keywords":""},{"title":"Signals & Hooks","type":0,"sectionRef":"#","url":"/DocumentService/docs/hooks","content":"","keywords":""},{"title":"Signals​","type":1,"pageTitle":"Signals & Hooks","url":"/DocumentService/docs/hooks#signals","content":"DocumentService provides 5 signals: UpdatedSignal, OpenedSignal, ReadSignal, ClosedSignal, CacheChangedSignal. These signals allow you to wait for a document to be open before modifying it or to tap into cache changes (e.g. for replication), for example. They also implement the Once and cancellation functionality of after hooks, through :Once and :Disconnect. They are implemented with sleitnick signals, so listeners are wrapped in a task.spawn and hence will run immediately (and before the method returns), until a yield is encountered, and will run in reverse order to the order they are added. "},{"title":"Hooks​","type":1,"pageTitle":"Signals & Hooks","url":"/DocumentService/docs/hooks#hooks","content":"Hooks are now deprecated (except for before hooks, which can be useful for debugging/logging). Use signals in new work instead. To listen to and respond to events, like saving or reading data, DocumentService has a hooks API: HookBefore, HookAfter, OnceBefore, and OnceAfter. Hooks run sequentially in the order they are added, and generally, should not yield. HookBefore and HookAfter return a cancel function. This will clean up the hook and stop it from running again in response to any future events. Note that once an event happens, the sequence of hooks to run is fixed and cannot be changed for while the hooks are running for that particular event. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/DocumentService/docs/installation","content":"","keywords":""},{"title":"Method 1: Wally​","type":1,"pageTitle":"Installation","url":"/DocumentService/docs/installation#method-1-wally","content":"Add DocumentService = &quot;anthony0br/documentservice@LATEST_VERSION&quot; to your wally.toml. "},{"title":"Method 2: Manual​","type":1,"pageTitle":"Installation","url":"/DocumentService/docs/installation#method-2-manual","content":"DocumentService has no dependencies so you can just copy and paste the contents oftarget/roblox into your project. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/DocumentService/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/DocumentService/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  "},{"title":"Setting Up Player Data","type":0,"sectionRef":"#","url":"/DocumentService/docs/tutorial","content":"","keywords":""},{"title":"Setup​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#setup","content":"Get the required services and libraries. local DataStoreService = game:GetService(&quot;DataStoreService&quot;) local DocumentService = require(path.to.DocumentService) local Guard = require(path.to.Guard)  Guard: Used to validate data types. "},{"title":"Player Data Structure​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#player-data-structure","content":"You need to define a structure for your data - this is called a schema. Define a type: It is useful to define your schema as a type. type DataSchema = { Coins: number, XP: number, }  You can add more fields as needed. Check function: The check function takes an unknown value (the value from Data Stores) and verifies that it meets the correct format by returning a boolean. The second return type must match the type of your default - however, this is only to help you prevent mistakes. A good way to create a check function is to use Guard. Create a standard interface check in Guard, and then wrap it with Guard.Check so it returns a boolean. Note that, while it is recommended that you use a check function, you can of course write one that always returns true if you are confident data won't be mistakenly corrupted! In the future, the check function may be optional. local DataInterface = { Coins = Guard.Integer, XP = Guard.Integer, } local function dataCheck(value: unknown): DataSchema assert(type(value) == &quot;table&quot;, &quot;Data must be a table&quot;) local Value: any = value return { Coins = DataInterface.Coins(Value.Coins), XP = DataInterface.XP(Value.XP), } end  "},{"title":"Creating the DocumentStore​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#creating-the-documentstore","content":"DocumentStore: Set up the DocumentStore for player data. local PlayerDocumentStore = DocumentService.DocumentStore.new({ dataStore = DataStoreService:GetDataStore(&quot;PlayerData&quot;), check = Guard.Check(dataCheck), default = { Coins = 0, XP = 0, }, migrations = { { backwardsCompatible = false, migrate = function() -- Put a migration here! end } }, -- This is an important feature of player data. It locks editing to one server -- at a time, allowing us to safely cache player data and save batches of updates. -- We do this through additional methods that session locking unlocks, such as -- `SetCache` and `GetCache`. lockSessions = true, })  migrations: Used to mutate your schema over time.backwardsCompatible: If false, the document with this version or later will not load in servers whose latest version is prior to this version. Otherwise, this version will run on old servers. Generally, removing or changing the type of a field is not backwards compatible, but adding fields is.lockSessions: Prevents multiple devices from accessing the same player's data simultaneously. "},{"title":"Best Practices​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#best-practices","content":"Strict types: Write your scripts in strict mode to benefit fully from the type-checking features of DocumentService. Be as precise as you can with types - using any or other loosely-defined types for your fields will have little to no benefit. Use good tools: Roblox Studio's script editor doesn't provide great linting - luau-lsp is better for taking full advantage of type-checking. Seperation: You might want to put your default table, migrations, types and your check function in a separate file to keep things manageable and modular. Use cache where you can: Minimise methods that call DataStore APIs, such as Read and Update, in favour of GetCache and SetCache. This improves performance and reduces the chance of hitting limits. "},{"title":"Editing Player Data​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#editing-player-data","content":"To modify the player's data on the Server: Note that this assumes the player is in the server! local document = YourPlayerDataModule:GetDocument(player) if not document:IsOpen() then -- See &quot;Waiting for a Document to Open&quot; page if you need to wait for the document to be open end -- We need to clone the table and any sub-tables we intend to edit, since -- DocumentService freezes tables on SetCache. -- This forces immutable updates and helps you avoid creating bugs! local documentClone = table.clone(document:GetCache()) documentClone.Coins = 99 documentClone.XP = 99 document:SetCache(documentClone)  document:SetCache(): Updates the player's data cache, which is saved when the document is closed. "},{"title":"Accessing Data from the Client​","type":1,"pageTitle":"Setting Up Player Data","url":"/DocumentService/docs/tutorial#accessing-data-from-the-client","content":"Access the player's data from the Client: -- Server GetPlayerData_Remote:Connect(function(player) local playerDocument = PlayerData:GetDocument(player) return playerDocument:GetCache() end) -- Client local playerDocument = GetPlayerData_Remote:Invoke() print(playerDocument.XP) -- 99 print(playerDocument.Coins) -- 99  playerDocument:Read(): Returns the player's data "},{"title":"SaveUtil","type":0,"sectionRef":"#","url":"/DocumentService/api/SaveUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#functions","content":" "},{"title":"assertStorable​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#assertStorable","content":"&lt;/&gt; SaveUtil.assertStorable( data: unknown, fieldName: string? ) → () Errors if the data passed is not storable in JSON Rejects: NaN (all numbers must equal themselves) Mixed table index types Non sequential tables indexed by numbers Non-string or number table indexes Cyclic tables type(value) == &quot;userdata&quot; Functions Metatables Threads Vectors  "},{"title":"uuid​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#uuid","content":"&lt;/&gt; SaveUtil.uuid() → string Luau uuid implementation. Based off of https://gist.github.com/jrus/3197011  "},{"title":"updateAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#updateAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.updateAsync( transform: ( (err: string) → (), unknown, DataStoreKeyInfo ) → ( any, {number}?, {}? ), dataStore: DataStoreInterface, key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for UpdateAsync that retries with exponential backoff, prevents use of the throttle 'queue', and allows retries to be aborted.  "},{"title":"getAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#getAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.getAsync( dataStore: DataStoreInterface, key: string ) → ( boolean, any, DataStoreKeyInfo ) A wrapper for GetAsync that retries with exponential backoff and prevents use of the throttle 'queue'.  "},{"title":"removeAsync​","type":1,"pageTitle":"SaveUtil","url":"/DocumentService/api/SaveUtil#removeAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; SaveUtil.removeAsync( dataStore: DataStoreInterface, key: string ) → boolean A wrapper for RemoveAsync "},{"title":"DocumentStore","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentStore","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#functions","content":" "},{"title":"new​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#new","content":"&lt;/&gt; DocumentStore.new(props: DocumentStoreProps) → DocumentStore&lt;T&gt; "},{"title":"Types","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore##","content":""},{"title":"​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#DocumentStoreProps","content":"interface DocumentStoreProps { dataStore: DataStore -- The object returned by DataStoreService:GetDataStore() check: (unknown) → ( boolean, T )-- A type check function for your data, errors if types are invalid default: T&amp;{}-- Default values, which are set if keys are empty migrations: Migrations-- Migrations lockSessions: boolean-- Should the documents be session locked? bindToClose: boolean?-- Should the DocumentStore close all documents on BindToClose? [default=true] (This should always be true in production) }  Creates a new DocumentStore. warning This should only be called once per server for each DataStore in a live game. If there are multiple instances of a DocumentStore for one key, any Documents will be treated as if they are from different sessions. This is useful for unit testing but can lead to weird bugs in production. DocumentStores should persist through an entire server's lifespan and are not garbage collected.  "},{"title":"GetDocument​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#GetDocument","content":"&lt;/&gt; DocumentStore.GetDocument( self: DocumentStore&lt;T&gt;, key: string ) → ( Document&lt;T&gt;, boolean-- whether a new document was created ) Gets the document for the key given, or creates one if it does not exist. info Documents are cached in a weak table, so once they are closed, they will be marked for garbage collection if you have no references to them. Be careful of references created by closures. Documents that are not session locked will be garbage collected once there are no other references to them.  "},{"title":"CloseAllDocuments​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#CloseAllDocuments","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; DocumentStore.CloseAllDocuments(self: DocumentStore&lt;T&gt;) → () Closes all open documents as fast as possible. This runs on BindToClose already. Will also wait for any documents that are opening to open, and then close them. warning Yields until all documents are closed. If there is a systematic error in your :Close, for example a hook errors, this could infinitely yield. Closes documents asynchronously when request budget allows, and yields all open documents are closed.  "},{"title":"isDocumentStore​","type":1,"pageTitle":"DocumentStore","url":"/DocumentService/api/DocumentStore#isDocumentStore","content":"&lt;/&gt; DocumentStore.isDocumentStore(instance: metatable) → boolean Checks if a metatable passed is a DocumentStore. "},{"title":"DocumentService","type":0,"sectionRef":"#","url":"/DocumentService/api/DocumentService","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#types","content":" "},{"title":"HookEvent​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#HookEvent","content":"&lt;/&gt; type HookEvent = &quot;Open&quot; | &quot;Close&quot; | &quot;Update&quot; | &quot;Read&quot; Update hooks will run on any operation that writes to Data Stores e.g. :Save(). Read hooks will run on any operation that reads from Data Stores e.g. :Peek()  "},{"title":"Ok<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Ok<T>","content":"&lt;/&gt; type Ok&lt;T&gt; = { success: true, data: T } Subtype of Result. A success.  "},{"title":"Err<E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Err<E>","content":"&lt;/&gt; type Err&lt;E&gt; = { success: false, reason: E } Subtype of Result. An error.  "},{"title":"Result<T,E>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Result<T,E>","content":"&lt;/&gt; type Result&lt;T,E&gt; = Ok&lt;T&gt; | Err&lt;E&gt; The result of a yielding operation that could error. You should always write error handling for all types of errors that can be returned.  "},{"title":"RobloxAPIError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#RobloxAPIError","content":"&lt;/&gt; type RobloxAPIError = &quot;RobloxAPIError&quot; Indicates the Roblox API failed, e.g. too many requests  "},{"title":"SessionLockedError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SessionLockedError","content":"&lt;/&gt; type SessionLockedError = &quot;SessionLockedError&quot; Indicates the document was locked by some other session.  "},{"title":"CheckError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#CheckError","content":"&lt;/&gt; type CheckError = &quot;CheckError&quot; Indicates the document's check function failed.  "},{"title":"BackwardsCompatibilityError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#BackwardsCompatibilityError","content":"&lt;/&gt; type BackwardsCompatibilityError = &quot;BackwardsCompatibleError&quot; Attempted to load data that has been migrated ahead to a version that isn't backwards compatible with the latest version our session has.  "},{"title":"SchemaError​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#SchemaError","content":"&lt;/&gt; type SchemaError = &quot;SchemaError&quot; This indicates the key provided is not managed by DocumentService, or has been corrupted. In the case of a SchemaError during opening, a new Document will be created, enclosing the existing value at the key.  "},{"title":"Migrations​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Migrations","content":"&lt;/&gt; type Migrations = {{ backwardsCompatible: boolean, migrate: (data: any) → any, }} Data format versions start at 0. The first migration should migrate from 0 to 1. If you have data existing in the key before you open a Document, this will be considered version 0 and migrations will run. If backwardsCompatible is false, loading this version and later versions in an older server without this migration defined will fail. The current version is defined by the length of this array. warning If you make a not-backwards-compatible migration on not-session-locked Documents, you must shut down all servers, or old servers will break.  "},{"title":"Transform<T>​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#Transform<T>","content":"&lt;/&gt; type Transform&lt;T&gt; = (data: T) → T Takes data and returns an updated version of it. Ideally this should be a pure function.  "},{"title":"DataStoreInterface​","type":1,"pageTitle":"DocumentService","url":"/DocumentService/api/DocumentService#DataStoreInterface","content":"&lt;/&gt; type DataStoreInterface = { UpdateAsync: ( DataStoreInterface, key: string, ( any, DataStoreKeyInfo ) → ( any, {number}?, any? ) ) → ( any, DataStoreKeyInfo ), GetAsync: ( DataStoreInterface, key: string, options: DataStoreGetOptions ) → ( any, DataStoreKeyInfo ), RemoveAsync: ( DataStoreInterface, key: string ) → ( any, DataStoreKeyInfo ) } An interface, implemented by DataStore in Roblox, to allow dependency injection (e.g. MockDataStores). There is currently an issue where passing DataStore will result in a type error, even though DataStore currently implements DataStoreInterface. You can typecast to to any (:: any) as a workaround. "},{"title":"Document","type":0,"sectionRef":"#","url":"/DocumentService/api/Document","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#types","content":" "},{"title":"OpenResult<T>​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OpenResult<T>","content":"&lt;/&gt; type OpenResult&lt;T&gt; = Result&lt;T,RobloxAPIError | BackwardsCompatibilityError | CheckError | SessionLockedError&gt;   "},{"title":"WriteResult<T>​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#WriteResult<T>","content":"&lt;/&gt; type WriteResult&lt;T&gt; = Result&lt;T,RobloxAPIError | SessionLockedError | SchemaError&gt;  "},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#functions","content":" "},{"title":"Open​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Open","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Open(self: Document&lt;T&gt;) → OpenResult&lt;T&gt; Validates the document if one exists, creates a default document if no document exists, or creates a document with the data that is in the given key if the key hasn't been used with DocumentService before. Opening a session-locked document will enable periodic autosaves until it is closed. You must open a document before reading or writing to it. info If the document is locked by another session, this method will wait and retry up to 5 times, and yields until the retries are exhausted or the lock is removed. Therefore, you should not use this method to check if the Document is being used by another session. warning You should check the value of success, and handle failures by checking the value of reason. The possible reasons for each method are defined in the return type.  "},{"title":"OpenAndUpdate​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OpenAndUpdate","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.OpenAndUpdate( self: Document&lt;T&gt;, transform: Transform&lt;T&gt; ) → OpenResult&lt;T&gt; Opens, and also runs a transform function on the data. Useful for non-session-locked data for shared entities, where one-off updates might be needed. Will throw a Luau error if the transform produces invalid or unsavable data. Runs both Open and Update hooks and signals, including fail hooks.  "},{"title":"Steal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Steal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Steal(self: Document&lt;T&gt;) → () Marks the lock as stolen. The next :Open call will ignore any existing locks. info Generally, it is recommended to call :Steal and then :Open in the case that the initial :Open fails due to SessionLockedError. warning Do not use this unless you are very sure the previous session is dead, or you could cause data loss. Only usable on session-locked Documents.  "},{"title":"GetOpenedSignal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetOpenedSignal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.GetOpenedSignal(self: Document&lt;T&gt;) → Signal&lt;OpenResult&lt;T&gt;&gt; Retrieves a signal that is fired when the document is opened. Note that this will be fired on completion of any :Open, even if it failed.  "},{"title":"GetClosedSignal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetClosedSignal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.GetClosedSignal(self: Document&lt;T&gt;) → Signal&lt;WriteResult&lt;T?&gt; Retrieves a signal that is fired when the document is closed. Note that this will be fired on completion of any :Close, even if it failed.  "},{"title":"GetUpdatedSignal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetUpdatedSignal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.GetUpdatedSignal(self: Document&lt;T&gt;) → Signal&lt;WriteResult&lt;T&gt;&gt; Retrieves a signal that is fired when the document is updated. For example, this will be fired after an autosave or after you call :Save(). Note that this will be fired on completion of any :Update, even if it failed.  "},{"title":"GetReadSignal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetReadSignal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.GetReadSignal(self: Document&lt;T&gt;) → Signal&lt;ReadResult&lt;T&gt;&gt; Retrieves a signal that is fired when the document is read. Note that this will be fired on completion of any :Read, even if it failed.  "},{"title":"GetCacheChangedSignal​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCacheChangedSignal","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.GetCacheChangedSignal(self: Document&lt;T&gt;) → Signal&lt;T&gt; Retrieves a signal that is fired when the document's cache is set.  "},{"title":"IsOpenAvailable​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsOpenAvailable","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.IsOpenAvailable(self: Document&lt;T&gt;) → Result&lt;boolean,RobloxAPIError&gt; Returns a false Result if Document is either: i. Currently open in this server ii. Currently locked by another session Otherwise returns a true Result. If props.lockSessions is false, this will always return a true Result. tip You can use this to check if a player is active to avoid data loss while editing data from another server.  "},{"title":"IsOpen​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsOpen","content":"&lt;/&gt; Document.IsOpen(self: Document&lt;T&gt;) → boolean Returns whether the document is open or not  "},{"title":"Close​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Close","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Close(self: Document&lt;T&gt;) → WriteResult&lt;T?&gt; Closes the document, so it cannot be edited. The document must be open before using this method. If session locked, will save the document, remove the lock, and cancel autosaves first. If this fails, the document will not be closed. If the Close performs a Save, Result.data will be the data saved.  "},{"title":"IsClosing​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#IsClosing","content":"&lt;/&gt; Document.IsClosing(self: Document&lt;T&gt;) → boolean Returns true if :Close has been called and is incomplete.  "},{"title":"SetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#SetCache","content":"&lt;/&gt; Document.SetCache( self: Document&lt;T&gt;, newCache: T ) → T Sets the cache. The document must be open before using this method. You can only use cache for session-locked data. warning Your cache should always pass your check function, otherwise autosaves may error. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"GetCache​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#GetCache","content":"&lt;/&gt; Document.GetCache(self: Document&lt;T&gt;) → T Retrieves the cache. The document must be open before using this method. You can only use cache for session-locked data. info You must use immutable operations on cache, i.e. clone any table you intend to edit.  "},{"title":"Update​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Update( self: Document&lt;T&gt;, transform: Transform&lt;T&gt;-- Transform function for the transaction. ) → WriteResult&lt;T&gt; Performs an atomic transaction on the Document, writing to the DataStore. The document must be open before using this method. If using session locking, passing a transform is equvialent to callingSetCache with the transformed data and then Save. It is recommended you do this instead and reserver the transform function for non-session-locked data. If the Save fails, the cache will still be updated. Throws if data is not storable or the transform return value is invalid. tip Due to Luau limitations with the old solver, you will get the best experience if you manually annotate the type of the transform parameter. warning The transform function must not yield, and shouldn't rely on any data from outside. It must follow the rules of what is storable in Data Stores. warning Assumes the data that is already in Data Stores is valid since the last:Open. If it isn't, and this is not corrected by the transform, this method will throw a luau error. warning If you are using session locking, your transform needs to use immutable operations (in the same way updating cache does). warning If your transform errors, the update will be aborted and the error will be thrown in a new thread (this is Roblox behaviour). info Unlike Open, this method will not retry if the lock is stolen, and will instead return a SessionLockedError after the first attempt.  "},{"title":"Save​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Save","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Save(self: Document&lt;T&gt;) → WriteResult&lt;T&gt; Saves a Document's cache to its DataStore. Equivalent to calling Update without transforming the data. The document must be open and locked to use this method. Returns a WriteResult with the data field being the data saved to Data Stores.  "},{"title":"Erase​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Erase","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Erase(self: Document&lt;T&gt;) → Result&lt;nil,RobloxAPIError&gt; Erases all data associated with the key. The document must not be open. It is up to you to check if the document is open elsewhere, e.g. via IsOpenAvailable. Satisfies compliance with GDPR right of erasure. Does not run hooks.  "},{"title":"Read​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#Read","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Document.Read(self: Document&lt;T&gt;) → Result&lt;any,RobloxAPIError | SchemaError | CheckError | BackwardsCompatibilityError&gt; Reads the latest data stored in Data Stores. Runs migrations and the check function, but does not save changes. This may be called while the document is not open. warning A SchemaError will be returned if document has never been opened before, so it is strongly recommended to handle this case, and Open the document before reading it if possible. This includes when migrating from no library. Runs Read hooks.  "},{"title":"HookBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookBefore","content":"&lt;/&gt; Document.HookBefore( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook before hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → cleanup-- a callback that removes the hook from the given hook event registry Attaches a hook which occurs before the event. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks cannot currently mutate arguments.  "},{"title":"OnceBefore​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceBefore","content":"&lt;/&gt; Document.OnceBefore( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook before hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs before the event.  "},{"title":"isDocument​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#isDocument","content":"&lt;/&gt; Document.isDocument(instance: metatable) → boolean Checks if a metatable passed is a Document.  "},{"title":"HookAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookAfter","content":"deprecated in v1.2.0 &lt;/&gt; This was deprecated in v1.2.0 use signals Document.HookAfter( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → cleanup-- a callback that removes the hook from the given hook event registry Attaches a hook which occurs after the event, before the method returns. Note that if a hook yields, it will yield all methods that call it. Hooks are called in the order they are added. Hooks added with HookAfter only run if the operation is successful, and cannot mutate the result.  "},{"title":"HookFail​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#HookFail","content":"deprecated in v1.2.0 &lt;/&gt; This was deprecated in v1.2.0 use signals Document.HookFail( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → cleanup-- a callback that removes the hook from the given hook event registry Attaches a hook which occurs after an event fails. Note that fail hooks only run when a method returns an Err type. They will not run if the method throws a Luau error due to incorrect usage.  "},{"title":"OnceAfter​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceAfter","content":"deprecated in v1.2.0 &lt;/&gt; This was deprecated in v1.2.0 use signals Document.OnceAfter( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs after the event, before the method returns.  "},{"title":"OnceFail​","type":1,"pageTitle":"Document","url":"/DocumentService/api/Document#OnceFail","content":"deprecated in v1.2.0 &lt;/&gt; This was deprecated in v1.2.0 use signals Document.OnceFail( self: Document&lt;T&gt;, event: HookEvent,-- the operation to call the hook after hook: () → ()-- a hook function that receives the arguments passed in to the operation ) → () Attaches a single-use hook which occurs after an event fails. "}]